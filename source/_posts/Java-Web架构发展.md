---
uuid: b709d091-2a77-11ea-a744-1f4d64ae768d
title: Java Web架构发展
date: 2019-06-22 16:06:08
author: 聂明照
categories:
- 技术
tags:
- Java
toc: true
---

前后端分离已成为互联网项目开发的业界标准使用方式，通过Nginx + Tomcat的方式（也可以中间加一个Node.js）有效的进行解耦，并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，iOS等等）打下坚实的基础。

<!-- more -->

这个步骤是系统架构从猿进化成人的必经之路。

核心思想是**前端HTML页面通过Ajax调用后端的RESTful API接口并使用JSON数据进行交互**。

> Web服务器：一般指像Nginx、Apache这类的服务器，他们一般只能解析静态资源。  
  应用服务器：一般指像Tomcat，Jetty，Resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有Web服务器好。  
  一般都是只有Web服务器才能被外网访问，应用服务器只能内网访问。

### 术业有专攻（开发人员分离）

以前的Java Web项目大多数都是Java程序员又当爹又当妈，又搞前端（Ajax/jQuery/JS/HTML/CSS等等），又搞后端（Java/MySQL/Oracle等等）。

随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。

正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。

大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。

* 对于后端Java工程师：

把精力放在Java基础、设计模式、JVM原理、Spring + SpringMVC原理及源码、Linux、MySQL事务隔离与锁机制、MongoDB、HTTP/TCP、多线程、分布式架构（Dubbo、DubboX、Spring Cloud）、弹性计算架构、微服务架构（SpringBoot + ZooKeeper + Docker + Jenkins）、Java性能优化以及相关的项目管理等等。

后端追求的是：*三高（高并发、高可用、高性能），安全，存储，业务等等*。

* 对于前端工程师：

把精力放在HTML5、CSS3、jQuery、AngularJS、Bootstrap、ReactJS、VueJS、Webpack、Less/Sass、Gulp、Node.js、Google V8引擎、JavaScript多线程、模块化、面向切面编程、设计模式、浏览器兼容性、性能优化等等。

前端追求的是：*页面表现，速度流畅，兼容性，用户体验等等*。

术业有专攻，这样你的核心竞争力才会越来越高，正所谓你往生活中投入什么，生活就会反馈给你什么。并且两端的发展都越来越高深，你想什么都会，那你毕竟什么都不精。

通过将Team分成前后端Team，让两边的工程师更加专注各自的领域，独立治理，然后构建出一个全栈式的精益求精的Team。

### 原始人时代（各种耦合）

曾几何时，我们的Java Web项目都是使用了若干后台框架，SpringMVC/Struts + Spring + SpringJDBC/Hibernate/MyBatis等等。

大多数项目在Java后端都是分了三层——控制层（Controller/Action）、业务层（Service/Model）、持久层（Dao）。

控制层负责接收参数，调用相关业务层，封装数据，以及路由&渲染到JSP页面。然后，JSP页面上使用各种标签（JSTL/EL/Struts标签等）或者手写Java表达式（<%= %>）将后台的数据展现出来，玩的是MVC那套思路。

我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？你需要用Maven或者Eclipse等工具把你的代码打成一个War包，然后把这个War包发布到你的生产环境下的Web容器（Tomcat/JBoss/WebLogic/WebSphere/Jetty/Resin）里，对吧？

发布完了之后，你要启动你的Web容器，开始提供服务，这时候你通过配置域名、DNS等等相关，你的网站就可以访问了（假设你是个网站）。

那我们来看，你的前后端代码是不是全都在那个War包里？包括你的JS、CSS、图片、各种第三方的库，对吧？

好，下面在浏览器中输入你的网站域名（www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）

我捡干的说了啊，基础不好的童鞋请自己去搜。

浏览器在通过域名通过DNS服务器找到你的服务器外网IP，将HTTP请求发送到你的服务器，在TCP 3次握手之后（HTTP下面是TCP/IP），通过TCP协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过Content-Type来解析你返回的内容，呈现给用户。

那么我们来看，先假设你的首页中有100张图片，此时，用户看似一次的HTTP请求，其实并不是一次。用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着发起100次HTTP请求（有人会跟我说HTTP长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建Socket来玩TCP传输（消耗你服务器上的计算资源）。

重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说单实例服务器），那你的服务器能扛住多少个TCP连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给Web服务器分的内存有多大？会不会宕机？

这就是为什么，**越是大中型的Web应用，他们越是要解耦**。

理论上你可以把你的数据库 + 应用服务 + 消息队列 + 缓存 + 用户上传的文件 + 日志 + 等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。

但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而
Hung住，那你的整个网站就挂掉了。

如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。

*注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期哟，亲~*

此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用**负载均衡**的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低。要知道，本身负载就低的功能或者模块是没有必要水平扩展的。在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？（引用自：《架构探险-轻量级微服务架构》，黄勇）

正常的互联网架构，是都要拆开的，你的Web服务器集群，你的应用服务器集群 + 文件服务器集群 + 数据库服务器集群 + 消息队列集群 + 缓存集群等等。

### JSP的痛点

以前的Java Web项目大多数使用JSP作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，我们需要寻找一种解耦的方式，来大幅度提升我们的负载能力。

1. 动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种HTTP请求，例如CSS的HTTP请求，JS的，图片的等等。一旦服务器出现状况，前后台一起玩完，用户体验极差。
2. UI出好设计图后，前端工程师只负责将设计图切成HTML，需要由Java工程师来将HTML套成JSP页面，出错率较高（因为页面中经常会出现大量的JS代码），修改问题时需要双方协同开发，效率低下。
3. JSP必须要在支持Java的Web服务器里运行（例如Tomcat，Jetty，Resin等），无法使用Nginx等（Nginx据说单实例HTTP并发高达5W，这个优势要用上），性能提不上来。
4. 第一次请求JSP，必须要在Web服务器中编译成Servlet，第一次运行会较慢。
5. 每次请求JSP都是访问Servlet再用输出流输出的HTML页面，效率没有直接使用HTML高（是每次哟，亲~）。
6. JSP内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。
7. 如果JSP中的内容很多，页面响应会很慢，因为是同步加载。
8. 需要前端工程师使用Java的IDE（例如Eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗？

基于上述的一些痛点，我们应该**把整个项目的开发权重往前移，实现前后端真正的解耦！**

### 开发模式

以前老的方式是：

1. 产品经理/领导/客户提出需求
2. UI做出设计图
3. 前端工程师做HTML页面
4. 后端工程师将HTML页面套成JSP页面（前后端强依赖，后端必须要等前端的HTML做好才能套JSP。如果HTML发生变更，就更痛了，开发效率低）
5. 集成出现问题
6. 前端返工
7. 后端返工
8. 二次集成
9. 集成成功
10. 交付

新的方式是：

1. 产品经理/领导/客户提出需求
2. UI做出设计图
3. 前后端约定接口&数据&参数
4. 前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&参数不变，就不用两边都修改代码，开发效率高）
5. 前后端集成
6. 前端页面调整
7. 集成成功
8. 交付

### 请求方式

以前老的方式是：

1. 客户端请求
2. 服务端的Servlet或Controller接收请求（后端控制路由&渲染页面，整个项目开发的权重大部分在后端）
3. 调用Service，Dao代码完成业务逻辑
4. 返回JSP
5. JSP展现一些动态的代码

新的方式是：

1. 浏览器发送请求
2. 直接到达HTML页面（前端控制路由&渲染页面，整个项目开发的权重前移）
3. HTML页面负责调用服务端接口产生数据（通过Ajax等等，后台返回JSON格式数据，JSON数据格式因为简洁高效而取代XML）
4. 填充HTML，展现动态效果，在页面上进行解析并操作DOM。

（有兴趣的童鞋可以访问一下阿里巴巴等大型网站，然后按一下F12，监控一下你刷新一次页面，他的HTTP是怎么玩的，大多数都是单独请求后台数据，使用JSON传输数据，而不是一个大而全的HTTP请求把整个页面包括动 + 静全部返回过来）

总结一下新的方式的请求步骤：

大量并发浏览器请求 ---> Web服务器集群(Nginx) ---> 应用服务器集群(Tomcat) ---> 文件/数据库/缓存/消息队列服务器集群

同时又可以分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。

### 前后端分离的优势

1. 可以实现真正的前后端解耦，前端服务器使用Nginx。

前端/Web服务器放的是CSS、JS、图片等等一系列静态资源（甚至你还可以把CSS、JS、图片等资源放到特定的文件服务器，例如阿里云的OSS，并使用CDN加速），前端服务器负责控制页面引用&跳转&路由，前端页面异步调用后端的接口，后端/应用服务器使用Tomcat（把Tomcat想象成一个数据提供者），加快整体响应速度。

（这里需要使用一些前端工程化的框架比如Node.js、ReactJS、Router、Redux、Gulp、Webpack）

2. 发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。

页面逻辑、跳转错误、浏览器兼容性问题、脚本错误、页面样式等问题，全部由前端工程师来负责。接口数据出错、数据没有提交成功、应答超时等问题，全部由后端工程师来解决。双方互不干扰，前端与后端是相亲相爱的一家人。

3. 在大并发情况下，可以同时水平扩展前后端服务器。

比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均PV。去参加阿里的技术峰会，听他们说他们的Web容器都是自己写的，就算他单实例抗10万HTTP并发，2000台是2亿HTTP并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。

4. 减少后端服务器的并发/负载压力

除了接口以外的其他所有HTTP请求全部转移到前端Nginx上，接口的请求调用Tomcat，参考Nginx反向代理Tomcat。且除了第一次页面请求外，浏览器会大量调用本地缓存。

5. 即使后端服务器暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。

6. 也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有App相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）

7. 页面显示的东西再多也不怕，因为是异步加载。

8. Nginx支持页面热部署，不用重启服务器，前端升级更无缝。

9. 增加代码的维护性&易读性（前后端耦合在一起的代码读起来相当费劲）。

10. 提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。

11. 在Nginx中部署证书，外网使用HTTPS访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），内网使用HTTP，性能和安全都有保障。

12. 前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！

### 注意事项

1. 在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，推荐使用Chrome的插件Postman或SoapUI或Jmeter，Service层的测试用例拿JUnit写。PS：前端也可以玩单元测试吗？
2. 上述的接口并不是Java里的interface，说白了调用接口就是调用你Controller里的方法。
3. 加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。
4. 我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）
5. 如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不需要任何架构，但是如果你的项目是外网项目，呵呵哒。
6. 以前还有人在使用类似于Velocity/FreeMarker等模板框架来生成静态页面，仁者见仁智者见智。
7. 这篇文章主要的目的是说JSP在大型外网Java Web项目中被淘汰掉，可没说JSP可以完全不学，对于一些学生朋友来说，JSP/Servlet等相关的Java Web基础还是要掌握牢的，不然你以为SpringMVC这种框架是基于什么来写的？
8. 如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过Ajax从接口里拿。**类似于数据校验这种，前后端都需要做！**
9. 对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&内存&CPU等等计算资源，你要记住一点就是：**服务端的计算资源是有限的**，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。
10. 前端需要有机制应对后端请求超时以及后端服务器宕机的情况，友好的展示给用户。

### 扩展阅读

1. 其实对于JS、CSS、图片这类的静态资源可以考虑放到类似于阿里云的OSS这类文件服务器上（如果是普通的服务器&操作系统，存储在到达PB级的文件后，或者单个文件夹内的文件数量达到3-5万，IO会有很严重的性能问题），再在OSS上配CDN（全国子节点加速），这样无论你在全国的哪个地方，你页面打开的速度像飞一样，并且你的Nginx的负载会进一步降低。
2. 如果你要玩轻量级微服务架构，要使用Node.js做网关，用Node.js的好处还有利于SEO优化，因为Nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的JS，这使得Web应用得不到良好的搜索引擎支持。同时因为Nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。浏览器发起的请求经过Nginx进行分发，URL请求统一分发到Node.js，在Node.js中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。
3. 如果遇到跨域问题，Spring4的CORS可以完美解决，但一般使用Nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。*JSONP的方式也被淘汰掉了。*
4. 如果想玩多端应用，注意要去掉Tomcat原生的Session机制，要使用Token机制，使用缓存（因为是分布式系统），做单点，对于Token机制的安全性问题，可以搜一下JWT。
5. 前端项目中可以加入Mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。

### 总结

前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。

千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了。需要区分前后端项目。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。

前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过Ajax来调用HTTP请求调用后端的RESTful API。

前端只需要关注页面的样式与动态数据的解析&渲染，而后端专注于具体业务逻辑。

> 本文引用自[风动静泉的博客](https://www.cnblogs.com/z00377750/)——[JavaWeb架构发展](https://www.cnblogs.com/z00377750/p/9136385.html)。如有侵权，请留言告知，及时撤除。
